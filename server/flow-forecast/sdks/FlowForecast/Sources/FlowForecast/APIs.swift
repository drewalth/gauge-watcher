// APIs.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

// MARK: - FlowForecastAPI

open class FlowForecastAPI {
  public static var basePath = "http://localhost:8000"
  public static var customHeaders: [String: String] = [:]
  public static var credential: URLCredential?
  public static var requestBuilderFactory: RequestBuilderFactory = URLSessionRequestBuilderFactory()
  public static var apiResponseQueue: DispatchQueue = .main
}

// MARK: - RequestBuilder

open class RequestBuilder<T> {

  // MARK: Lifecycle

  required public init(
    method: String,
    URLString: String,
    parameters: [String: Any]?,
    headers: [String: String] = [:],
    requiresAuthentication: Bool)
  {
    self.method = method
    self.URLString = URLString
    self.parameters = parameters
    self.headers = headers
    self.requiresAuthentication = requiresAuthentication

    addHeaders(FlowForecastAPI.customHeaders)
    addCredential()
  }

  // MARK: Open

  open func addHeaders(_ aHeaders: [String: String]) {
    for (header, value) in aHeaders {
      headers[header] = value
    }
  }

  @discardableResult
  open func execute(
    _: DispatchQueue = FlowForecastAPI.apiResponseQueue,
    _: @escaping (_ result: Swift.Result<Response<T>, ErrorResponse>) -> Void)
    -> RequestTask
  {
    requestTask
  }

  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  @discardableResult
  open func execute() async throws -> Response<T> {
    try await withTaskCancellationHandler {
      try Task.checkCancellation()
      return try await withCheckedThrowingContinuation { continuation in
        guard !Task.isCancelled else {
          continuation.resume(throwing: CancellationError())
          return
        }

        self.execute { result in
          switch result {
          case .success(let response):
            continuation.resume(returning: response)
          case .failure(let error):
            continuation.resume(throwing: error)
          }
        }
      }
    } onCancel: {
      self.requestTask.cancel()
    }
  }

  open func addCredential() {
    credential = FlowForecastAPI.credential
  }

  // MARK: Public

  public let parameters: [String: Any]?
  public let method: String
  public let URLString: String
  public let requestTask = RequestTask()
  public let requiresAuthentication: Bool
  /// Optional block to obtain a reference to the request's progress instance when available.
  public var onProgressReady: ((Progress) -> Void)?

  public func addHeader(name: String, value: String) -> Self {
    if !value.isEmpty {
      headers[name] = value
    }
    return self
  }

  // MARK: Internal

  var credential: URLCredential?
  var headers: [String: String]

}

// MARK: - RequestBuilderFactory

public protocol RequestBuilderFactory {
  func getNonDecodableBuilder<T>() -> RequestBuilder<T>.Type
  func getBuilder<T: Decodable>() -> RequestBuilder<T>.Type
}
